// ====== Estado do cronômetro ======
let running = false;
let baseStartMs = 0;   // performance.now() no início/reinício
let accSeconds = 0;   // segundos acumulados quando pausado
let tickInterval = null;

const periodEl = document.getElementById('period');
const clockEl  = document.getElementById('clock');
const btnToggle = document.getElementById('btnToggleTimer');
const btnReset  = document.getElementById('btnResetTimer');

// ====== Dados dos eventos ======
let nextId = 0;
const events = []; // {id, code, start, end, labels[]}
const counts = {}; // {code: number}

// Mapeia todos os códigos que existem (gera contadores e cores no XML/ROWS)
const EVENT_CODES = [
  'FIN_LEC','FIN_ADV',
  'ENT_LAT_LEC','ENT_CEN_LEC','ENT_PROF_LEC',
  'ENT_LAT_ADV','ENT_CEN_ADV','ENT_PROF_ADV'
];

// Inicializa contadores
EVENT_CODES.forEach(c => counts[c] = 0);

// ====== Util ======
function formatTimeMMSS(seconds){
  const s = Math.max(0, Math.floor(seconds));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s % 60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function nowSeconds(){
  if (!running) return accSeconds;
  const elapsed = (performance.now() - baseStartMs) / 1000;
  return accSeconds + elapsed;
}

function updateClock(){
  clockEl.textContent = formatTimeMMSS(nowSeconds());
}

// ====== Cronômetro ======
function startOrPause(){
  if (!running){
    // Iniciar/Retomar
    running = true;
    baseStartMs = performance.now();
    btnToggle.textContent = 'Pausar';
    tickInterval = setInterval(updateClock, 100);
  } else {
    // Pausar
    running = false;
    accSeconds = nowSeconds(); // congela no momento atual
    btnToggle.textContent = 'Retomar';
    if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
    updateClock();
  }
}

function resetTimer(){
  running = false;
  accSeconds = 0;
  if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
  btnToggle.textContent = 'Iniciar';
  updateClock();
}

// ====== Interações ======
btnToggle.addEventListener('click', startOrPause);
btnReset.addEventListener('click', resetTimer);

// Clique nos botões de eventos
document.addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-code]');
  if (!btn) return;

  if (!running){
    alert('Inicie o cronômetro para registrar eventos.');
    return;
  }

  const code = btn.getAttribute('data-code');
  tagEvent(code);
});

// Lógica principal do tagueamento
function tagEvent(code){
  const t = nowSeconds();
  const start = Math.max(0, t - 25);
  const end   = t + 10;

  events.push({
    id: nextId++,
    code,
    start,
    end,
    labels: [{ group: 'Event', text: code }]
  });

  // Atualiza contador visual
  counts[code] = (counts[code] || 0) + 1;
  const badge = document.getElementById(`count_${code}`);
  if (badge) badge.textContent = counts[code];
}

// ====== Exportações ======
document.getElementById('btnExportCSV').addEventListener('click', exportCSV);
document.getElementById('btnExportXML').addEventListener('click', exportXML);

function exportCSV(){
  // Apenas contadores
  let csv = 'Code,Count\n';
  EVENT_CODES.forEach(code => {
    csv += `${code},${counts[code] || 0}\n`;
  });

  downloadFile(csv, `contadores_${todayISO()}.csv`, 'text/csv;charset=utf-8;');
}

function exportXML(){
  // Gera instâncias + ROWS
  const xml = buildXML();
  downloadFile(xml, `eventos_${todayISO()}.xml`, 'text/xml;charset=utf-8;');
}

function buildXML(){
  const rows = getRowDefinitions();

  let xml = '';
  xml += `<?xml version="1.0" encoding="UTF-8"?>\n`;
  xml += `<file>\n`;
  xml += `    <!--Generated by LiveTagPRO-->\n`;
  xml += `    <SORT_INFO>\n`;
  xml += `        <sort_type>sort order</sort_type>\n`;
  xml += `    </SORT_INFO>\n`;
  xml += `    <ALL_INSTANCES>\n`;

  events.forEach(ev => {
    xml += `        <instance>\n`;
    xml += `            <ID>${ev.id}</ID>\n`;
    xml += `            <code>${ev.code}</code>\n`;
    xml += `            <start>${ev.start.toFixed(6)}</start>\n`;
    xml += `            <end>${ev.end.toFixed(6)}</end>\n`;
    ev.labels.forEach(l => {
      xml += `            <label>\n`;
      xml += `                <group>${l.group}</group>\n`;
      xml += `                <text>${l.text}</text>\n`;
      xml += `            </label>\n`;
    });
    xml += `        </instance>\n`;
  });

  xml += `    </ALL_INSTANCES>\n`;
  xml += `    <ROWS>\n`;

  rows.forEach((row) => {
    xml += `        <row>\n`;
    xml += `            <sort_order>${row.sort_order}</sort_order>\n`;
    xml += `            <code>${row.code}</code>\n`;
    xml += `            <R>${row.R}</R>\n`;
    xml += `            <G>${row.G}</G>\n`;
    xml += `            <B>${row.B}</B>\n`;
    xml += `        </row>\n`;
  });

  xml += `    </ROWS>\n`;
  xml += `</file>\n`;

  return xml;
}

// Definição de cores (0-65535) e sort_order únicos
function getRowDefinitions(){
  return [
    { code: 'FIN_LEC',       sort_order: 1,  R: 65535, G: 12000, B: 8000 }, // laranja forte
    { code: 'FIN_ADV',       sort_order: 2,  R: 12000, G: 20000, B: 65535 }, // roxo/azulado
    { code: 'ENT_LAT_LEC',   sort_order: 3,  R: 0,     G: 50000, B: 60000 }, // ciano
    { code: 'ENT_CEN_LEC',   sort_order: 4,  R: 25000, G: 0,     B: 65535 }, // violeta
    { code: 'ENT_PROF_LEC',  sort_order: 5,  R: 0,     G: 48000, B: 0     }, // verde
    { code: 'ENT_LAT_ADV',   sort_order: 6,  R: 65535, G: 38000, B: 18000 }, // âmbar
    { code: 'ENT_CEN_ADV',   sort_order: 7,  R: 35000, G: 35000, B: 35000 }, // cinza
    { code: 'ENT_PROF_ADV',  sort_order: 8,  R: 20000, G: 5000,  B: 5000  }  // bordo
  ];
}

function todayISO(){
  return new Date().toISOString().split('T')[0];
}

function downloadFile(content, filename, mime){
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

// ====== PWA: registra Service Worker ======
if ('serviceWorker' in navigator){
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js').catch(console.error);
  });
}

// Inicializa relógio na UI
updateClock();
